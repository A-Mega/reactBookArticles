<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>React [RU] Tutorial v2</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/prop-types@15.6/prop-types.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">

      const myNews = [
        {
          id: 1,
          author: 'jone',
          text: '11 библиотек (наборов компонентов) для React Native, о которых стоит знать в 2018-м',
          bigText: 'В начале года мы опубликовали несколько материалов о популярных наборах компонентов для React, Angular и Vue. Сегодня мы представляем вашему вниманию перевод статьи из той же серии, посвящённой React Native. Учитывая непрекращающийся рост популярности React, и то, что мобильные приложения и PWA становятся всё востребованнее, неудивителен тот факт, что React Native привлекает всё большее внимание сообщества разработчиков.'
        },
        {
          id: 2,
          author: 'fee',
          text: 'Var, let или const? Проблемы областей видимости переменных и ES6',
          bigText: 'Области видимости в JavaScript всегда были непростой темой, особенно в сравнении с более строго организованными языками, такими, как C и Java. В течение многих лет области видимости в JS особенно широко не обсуждались, так как в языке попросту не было средств, которые позволяли бы существенно повлиять на сложившуюся ситуацию. Но в ECMAScript 6 появились некоторые новые возможности, которые позволяют разработчикам лучше контролировать области видимости переменных. Эти возможности в наши дни уже очень хорошо поддерживают браузеры, они вполне доступны для большинства разработчиков. Однако новые ключевые слова для объявления переменных, учитывая ещё и то, что старое ключевое слово var никуда не делось, означают не только новые возможности, но и появление новых вопросов. Когда использовать ключевые слова let и const? Как они себя ведут? В каких ситуациях всё ещё актуально ключевое слово var? Материал, перевод которого мы сегодня публикуем, направлен на исследование проблемы областей видимости переменных в JavaScript.'
        },
        {
          id: 3,
          author: 'Tenphi',
          text: 'Иван Тулуп: асинхронщина в JS под капотом',
          bigText: 'Об этом и о том, как работает асинхронщина в JS под капотом, как Event Loop работает в браузерах и в Node.js, есть ли какие-то различия и, может быть, похожие вещи рассказал Михаил Башуров (SaitoNakamura) в своем докладе на РИТ++. С удовольствием делимся с вами расшифровкой этого познавательного выступления.'
        },
        {
          id: 4,
          author: 'ru_vds',
          text: 'Vuex: структурирование больших проектов и работа с модулями',
          bigText: 'Vuex — это официальная, отлично документированная библиотека для управления состоянием приложений, разработанная специально для фреймворка Vue.js. Автор материала, перевод которого мы сегодня публикуем, полагает, что пользоваться этой библиотекой гораздо приятнее, чем Redux, так как, во-первых, для работы с Vuex требуется меньше шаблонного кода, а во-вторых — из-за того, что для работы с асинхронными механизмами здесь не нужно дополнительных библиотек. Более того, так как библиотека Vuex создана той же командой, которая занимается работой над Vue, эта библиотека очень хорошо интегрируется с данным фреймворком. К сожалению, в работе с Vuex всё ещё можно столкнуться с одной сложностью, которая заключается в правильной подготовке структуры проектов, в которых планируется пользоваться этой библиотекой.'
        }
      ];

      class Article extends React.Component {
        state = {
          visible: false, //!!! Я БЫ ПОМЕНЯЛ НА TRUE И ПЕРЕДЕЛАЛ В render
        }
        handleReadMoreClck = (e) => {
          e.preventDefault() //Отменяет событие, если оно отменяемое, без остановки дальнейшего распространения этого события.
          this.setState({ visible: true })
        }
        render() {
          const { author, text, bigText } = this.props.data
          //console.log('Article', author, text, bigText)
          const { visible } = this.state
          return (
            <div className='article'>
              <p className='news__author'>{author}:</p>
              <p className='news__text'>{text}</p>
              <hr />
              {
                !visible && <a onClick={this.handleReadMoreClck} href="#" className='news__readmore'>Подробнее</a>
              }
              {
                visible && <p className='news__big-text'>{bigText}</p>
              }
            </div>
          )
        }
      }

      //структура
      Article.propTypes = {
        data: PropTypes.shape({
          id: PropTypes.number.isRequired,
          author: PropTypes.string.isRequired,
          text: PropTypes.string.isRequired,
          bigText: PropTypes.string.isRequired
        })
      }

      class News extends React.Component {

        renderNews = () => {
          const { data } = this.props
          let newsTemplate = null
          
          if (data.length) {
            newsTemplate = data.map(function(item) {
              return <Article key={item.id} data={item}/>
            })
          } else {
            newsTemplate = <p>К сожалению новостей нет</p>
          }
          
          return newsTemplate
        }
        render() {
          const { data } = this.props
          
          return (
            <div className='news'>
              {this.renderNews()}
              {
                data.length ? <strong className={'news__count'}>Всего новостей: {data.length}</strong> : null
              }
            </div>
          );
        }
      }

      News.propTypes = {
        data: PropTypes.array.isRequired
      }

      class Add extends React.Component {
        //начальные значения:
        state = {
          name: '',
          text: '',
          bigText: '',
          agree: false,
        }
        onBtnClickHandler = (e) => {
          e.preventDefault()
          const { name, text, bigText } = this.state //вытащили значения из стейта (деструкторизация)
          //console.log('Add', name, text, bigText)
          //передаём name & text
          //big text пока отсутствует

          //alert(name + '\n' + text)
          this.props.onAddNews({ 
            id: +new Date(),
            author: name, 
            text, 
            bigText 
          })
        }
        //вычисляемое значение ключа:
        handleChange = (e) => {
          const { id, value } = e.currentTarget
          this.setState({ [id]: e.currentTarget.value })
        }
        //обработчие кликов по чекбоксу:
        handleCheckboxChange = (e) => {
          this.setState({ agree: e.currentTarget.checked })
        }
        //валидация на клиенте:
        validate = () => {
          const { name, text, agree } = this.state
          if (name.trim() && text.trim() && agree) { //bigText not required field
            return true
          }
          return false
        }
        render() {
          const { name, text, bigText, agree } = this.state
          return (
            <form className='add'>
              <input
                id='name'
                type='text'
                onChange={this.handleChange}
                className='add__author'
                placeholder='Ваше имя'
                value={name}
              />
              <textarea
                id='text'
                onChange={this.handleChange}
                className='add__text'
                placeholder='Заголовок новости'
                value={text}
              ></textarea>
              <textarea
                id='bigText'
                onChange={this.handleChange}
                className='add__text'
                placeholder='Текст новости'
                value={bigText}
              ></textarea>
              <label className='add__checkrule'>
                <input type='checkbox' onChange={this.handleCheckboxChange} /> Я согласен с правилами
              </label>
              <button
                className='add__btn'
                onClick={this.onBtnClickHandler}
                disabled={!this.validate()}> { /* блокировка кнопки если не все поля заполнены */}
                Показать alert
              </button>
            </form>
          )
        }
      }

      Add.propTypes = {
        onAddNews: PropTypes.func.isRequired
      }

      class App extends React.Component {
        state = {
          news: myNews //в начальное состояние положили значение из переменной
        }

        handleAddNews = (data) => {
          //формируем новый массив
          const nextNews = [data, ...this.state.news]
          
          this.setState({ news: nextNews })
        }

        render() {
          return (
            <React.Fragment>
              <Add onAddNews={this.handleAddNews} />
              <h3>Новости</h3>
              {/* считали новости из this.state */}
              <News data={this.state.news}/>
            </React.Fragment>
          )
        }
      }

      ReactDOM.render(
        <App />,
        document.getElementById('root')
      );

    </script>

  </body>
</html>